# ASM Lens — пример

## Быстрый старт

### 1. Скомпилировать пример с отладочной информацией

```bash
gcc -g -O1 -o main main.c math_utils.c
```

Флаги:
- `-g` — DWARF-отладка (обязательно, без неё маппинг не работает)
- `-O1` — оптимизации, чтобы ассемблер был интереснее (можно `-O0`, `-O2`)

### 2. Установить расширение (если ещё не установлено)

```bash
code --install-extension ../bin/asm-lens-0.1.0.vsix
```

### 3. Открыть папку example в VS Code

```bash
code .
```

### 4. Запустить

1. `Ctrl+Shift+P` → **ASM Lens: Show Assembly**
2. Справа откроется панель с дизассемблером
3. Строки исходника и ассемблера окрашены в одинаковые цвета (матчинг)
4. Кликните на строку — соответствующие строки подсветятся ярче

## Структура

```
example/
├── main.c            — точка входа, вызывает функции из math_utils
├── math_utils.h      — заголовок с объявлениями
├── math_utils.c      — реализация функций (square, sum_squares)
├── .asm-lens.json    — конфиг для ASM Lens
└── README.md         — эта инструкция
```

Два файла (`main.c` и `math_utils.c`) показывают, что ASM Lens корректно
работает с многофайловыми проектами — маппинг строк работает для всех
исходников, скомпилированных в один бинарник.

## Конфиг .asm-lens.json

```json
{
  "binary": "./main",
  "sourceRoot": ".",
  "objdump": "objdump",
  "objdumpArgs": ["-M", "intel"],
  "sections": [".text"]
}
```

- `binary` — путь до скомпилированного бинарника
- `sourceRoot` — корень исходников (для резолва путей из DWARF)
- `objdump` — путь к objdump/llvm-objdump (auto-detect по умолчанию)
- `objdumpArgs` — дополнительные аргументы (например `["-M", "intel"]` для Intel-синтаксиса)
- `sections` — секции для дизассемблирования (по умолчанию `.text`)
